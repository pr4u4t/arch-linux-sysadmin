#!/bin/bash

declare -a _args

function errorOut
{
	local ret=1
	local msg=""
	
	if (( $# >= 1 )); then
		msg="${1}"
	fi

	if [ $# == 2 ]; then
		ret="${2}"
	fi

	if [ ! -z "${msg}" ]; then
		echo -e "${msg}"
	fi

	exit "${ret}"
}

function checkWrite
{
	local base
	
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be ${FUNCNAME} path"
		return 1
	fi  

	if [ -f "${1}" ]; then
		if [ ! -w "${1}" ]; then
			echo -e "File:${1} is not writeable"
			return 2
		fi  
	else
		base=$(dirname "${1}")
		if [ ! -w "${base}" ]; then
			echo -e "Path:${base} is not writeable"
			return 3
		fi  
	fi  
}

function checkExec
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be ${FUNCNAME} file"
		return 1
	fi
	
	if [ ! -x "${1}" ]; then
		return 2
	fi
}

function checkRead
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be ${FUNCNAME} file"
		return 1
	fi

	if [ -f "${1}" ]; then
		if [ ! -r "${1}" ]; then
			echo -e "File:${1} is not readable"
			return 2
		fi  
	else
		echo -e "File:${1} does not exist"
		return 3
	fi
}

function emptyDir
{
	local base

	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be ${FUNCNAME} dir-path"
		return 1
	fi

	if [ -d "${1}" ]; then
		rm -rf ${1}/* &> /dev/null || ( echo -e "Failed to remove directory:${1} content" && return 2 )
	else
		base=$(dirname "${1}")
		
		if [ ! -w "${base}" ]; then
			echo -e "No write permission on directory:${base}"
			return 3
		fi

		mkdir "${1}" &> /dev/null || ( echo -e "Failed to create directory:${1}" && return 4 )
	fi
}

function userHome
{
	if [ $# != 1 ]; then 
		echo -e "Invalid number of arguments should be: ${FUNCNAME} user-name"
		return 1
	fi
	
	id -u "${1}" &> /dev/null || ( echo -e "User: ${1} not found" && return 2 )

	cat /etc/passwd | grep -E -e "^${1}:" | awk 'BEGIN { FS = ":" } ; { print $6 }' || ( echo -e "Home directory for user:${1} not found" && return 3 )
}

function changeHome
{
	local userHome

	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} user-name home-dir"
		return 1
	fi

	userHome=`userHome "${1}"`
	if [ "${userHome}" == "${2}" ]; then
		return 0
	fi

	usermod -m -d "${2}" "${1}" || ( echo -e "Failed to change home directory of user:${1}" to:${2} from:${userHome} && return 2 )
}

function copy 
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} read-path write-path"
		return 1
	fi

	checkRead "${1}" || return 2 
	checkWrite "${2}" || return 3

	cp -f "${1}" "${2}" &> /dev/null || ( echo -e "Copying failed from: ${1} to: ${2}" && return 4 )
}

function checkInstall
{
	local result

	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be ${FUNCNAME} package"
		return 1
	fi	
	
	pacman -Sy  &> /dev/null || ( echo -e "Failed to update pacman package database" && return 2 )

	result=`pacman -Qs "${1}" | grep -Eo -e "(local/${1})[\t ]+[0-9A-Za-z\.-]+"`

	if [ -z "${result}" ]; then
        	echo -e "${1} not found attempting to install"
        	pacman -S --noconfirm "${1}" &> /dev/null || ( echo -e "Failed to install ${1}" && exit 2 )
		echo -e "${1} successfully installed"
	else
        	echo -e "${1} already installed"
	fi
}

function getVariable
{
	local regex
	local ret
	local tmp
	local line
	
	if (( $# < 3 || $# > 4 )); then
		echo -e "Invalid number of arguments should be ${FUNCNAME} file var_name type [regex]"
		echo -e "type: raw,text,alnum,alpha,integer,float,bool,boolean,mixed,dns,ip,ipmask,port,ipport,user,custom"
		return 1
	fi

	checkRead "${1}" || return 2

	if [ $# == 3 ]; then
		if [ "${3}" == "text" ]; then
			regex="([[:alnum:]]|[[:blank:]])+"
		fi

		if [ "${3}" == "alnum" ]; then
			regex="[[:alnum:]]+"
		fi

		if [ "${3}" == "alpha" ]; then
			regex="[[:alpha:]]+"
		fi
		
		if [ "${3}" == "lower" ]; then
			regex="[[:lower:]]+"
		fi
	
		if [ "${3}" == "upper" ]; then
			regex="[[:upper:]]+"
		fi

		if [ "${3}" == "integer" ]; then
			regex="[0-9]+"
		fi

		if [ "${3}" == "float" ]; then
			regex="[0-9]+(\.[0-9]+){0,1}"
		fi

		if [ "${3}" == "bool" ]; then
			regex="((1)|(0))"
		fi

		if [ "${3}" == "boolean" ]; then
			regex="((true)|(false))"
		fi 

		if [ "${3}" == "mixed" ]; then
			regex="[A-Za-z0-9\.]+"
		fi

		if [ "${3}" == "path" ]; then
			regex="[A-Za-z/\.]+"
		fi

		if [ "${3}" == "dns" ]; then
			regex="[A-Za-z0-9\.]+"
		fi

		if [ "${3}" == "ip" ]; then
			regex="(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
		fi

		if [ "${3}" == "ipmask" ]; then
			regex="(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/)((3[0-2])|(2[0-9])|(1[0-9])|[1-9])"
		fi

		if [ "${3}" == "port" ]; then
			regex="(0*(?:6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]))"
		fi

		if [ "${3}" == "ipport" ]; then
			regex="(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(:)(0*(?:6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]))"
		fi

		if [[ "${3}" == "user" || "${3}" == "group" ]]; then
			regex="[A-Za-z]+([0-9]*[A-Za-z]*)*"
		fi
	else
		if [ $# == 4 ]; then
			if [ "${3}" == "custom" ]; then
				regex="${4}"
			fi
		fi
	fi

	#if [ -z "${regex}" ]; then
	if [[ "${3}" != "raw" && -z "${regex}" ]]; then
		echo -e "Unknown variable type" 1>&2
		return 3
	fi

	#cut comments and empty lines
	ret="$( cat "${1}" | grep -Ev "^[[:blank:]]*#|^[[:blank:]]*$" | sed  "s/#.*$//g" )"

	#check configuration file syntax
	tmp="$( echo "${ret}" | grep -m 1 -Env "^[[:blank:]]*[A-Za-z_][A-Za-z0-9_]+=\".*\"" )"
	if [ $? == 0 ]; then
		line="$( echo -e "${tmp}" | awk 'BEGIN { FS=":" } ; { print $1 }' )"
		echo -e "Syntax error, line: $line" 1>&2 
		return 4
	fi

	#get variable line
	ret="$( echo "${ret}" | grep -Eo -e "^[[:blank:]]*${2}=\".*\"" )" 
	if [ -z "${ret}" ]; then
		echo -e "Variable:${2} does not exist in: ${1}" 1>&2
		return 5
	fi

	if [ "${3}" == "raw" ]; then
		ret="$( echo "${ret}" | grep -Eo -e "\".*\"" | sed 's#^.##' | sed 's#.$##' )"
	else

		ret="$( echo  "${ret}" | grep -Eo -e "\"${regex}\"" | grep -Eo -e "${regex}" )"
		#if [ -z "${ret}" ]; then
		if [ $? != 0 ]; then
			echo -e "Variable:${2} value does not match regular expression:${regex}" 1>&2
			return 6
		fi
	fi

	ret=( "$(echo "${ret}")" )

	echo "${ret[@]}"
}

function setVariable
{
	local buffer

	if [ $# != 3 ]; then
		echo -e "Invalid number of arguments should be ${FUNCNAME} file variable_name variable_value"
		return 1
	fi
	
	checkWrite "${1}" || return 2
	
	buffer=`cat "${1}"` 
	echo -e "${buffer}" | sed -r "s#\\$\\{${2}\\}#${3}#g" > "${1}" || ( echo -e "Failed to write filei: ${1}" && return 3 )
}

function checkProceed
{
	local msg
	local action
	
	if [ $# == 1 ]; then
		msg="${1} (y/N) "
	else
		echo -en "Warning this would wipe any of your previous configuration would you like to proceed (y/N) "
	fi
	
	echo -en "${msg}"

	read action
	if [ "${action}" != "y" ]; then
		return 1
	fi
}

function serviceStatus
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} service-name"
		return 1
	fi

	systemctl status "${1}.service" | sed -n 3p | grep -oE -e "[ ][a-zA-Z0-9]+[ ]" | sed -n 1p | grep -oE -e "[a-z]+"
}

function serviceFile
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} service-name"
		return 1
	fi
	
	if [ ! -z "$( systemctl status "${1}.service" | awk '{ if(NR==2) { print } }' | grep -Eo -e "not-found" )" ]; then
		echo -e "not found"
		return 2
	fi
	
	systemctl status "${1}.service" | awk '{ if(NR==2) { print } }' | grep -Eo -e "\(.+\)" | grep -Eo -e "[A-Za-z0-9:;/\. -]+" | awk 'BEGIN { FS=" " } ; { print $1}' | grep -Eo -e "[/A-Z0-9a-z\.-]+"
}

function getUserById
{
	if [ $# != 1  ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} user-id"
		return 1
	fi

	cat /etc/passwd | grep -Eo -e "^([A-Za-z]+[A-Za-z0-9]*):(x):(${1})" | awk 'BEGIN { FS=":" } ; { print $1 }' || return 2
}

function getGroupById
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be:"
		return 1
	fi	

	cat /etc/group | grep -Eo -e "^([A-Za-z]+[A-Za-z0-9]*):(x):(${1})" | awk 'BEGIN { FS=":" } ; { print $1 }'
}

function checkUserExist
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} user-name"
		return 1
	fi
	
	id -u "${1}" &> /dev/null || return 2
}

function checkGroupExist
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} group-name"
		return 1
	fi

	id -g "${1}" &> /dev/null || return 2
}

function addUser
{

	if [[ $# < 1 && $# > 2 ]]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} user-name [comment]"
		return 1
	fi

	if [ $( checkUserExist "${1}" ) ]; then
		echo -e "Specified user:${1} already exists"
		return 2
	fi

	if [ -d "/home/${1}" ]; then
		echo -e "User home directory already exists"
		return 3
	fi
	
	if [ $# == 2 ]; then 
		useradd -m -c "${2}" "${1}"
	else
		useradd -m "${1}"
	fi
}

function getPathUser
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} path"
		return 1
	fi

	if [ -d "${1}" ]; then
		ls -lah | grep -E -e "[ \t]+\\.$" | awk '{ print $3 }'
	fi

	if [ -f "${1}" ]; then
		ls -lah | awk '{ print $3 }'
	fi
}

function getPathGroup
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} path"
		return 1
	fi

	if [ -d "${1}" ]; then
		ls -lah | grep -E -e "[ \t]+\\.$" | awk '{ print $4 }'
		return 0
	fi

	if [ -f "${1}" ]; then
		ls -lah | awk '{ print $4 }'
		return 0
	fi

	return 2
}

function checkDir
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments"
		return 1
	fi	

	if [ -d "${1}" ]; then
		if [ ! -x "${1}" ]; then
			echo -e "Directory:${1} not listable"
			return 2
		fi
	else
		echo -e "Directory:${1} does not exist"
		return 3
	fi
}

function touchDirectory
{
	if (( $# < 2 || $# > 6 )); then
		echo -e "Invalid number of arguments should be:${FUNCNAME} dir-path owner [group=owner] [owner-perm=rwx] [group-perm=r] [other-perm=]"
		return 1
	fi

	local path="${1}"
	local owner="${2}"
	local group="${owner}"

	local ownerPerm="rwx"
	local groupPerm="r"
	local otherPerm=""

	if (( $# >= 3 )); then
		group="${3}"
	fi

	if (( $# >= 4 )); then
		ownerPerm="${4}"
	fi

	if (( $# >= 5 )); then
		groupPerm="${5}"
	fi

	if (( $# == 6 )); then
		otherPerm="${6}"
	fi

	if [ ! -d "${path}" ]; then
		mkdir -p "${path}" || return 2
	fi

	chown "${owner}:${group}" "${path}" || return 3
	chmod "u=${ownerPerm}" "${path}" || return 4
	chmod "g=${groupPerm}" "${path}" || return 5
	chmod "o=${otherPerm}" "${path}" || return 6
}

function getPermissions
{
	local perms

	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} (owner|group|other)"
		return 1
	fi

	perms=`ls -lah "${1}" | awk 'BEGIN { FS=" " } ; { print $1 }'`

	if [ "${2}" == "owner" ]; then
		echo -e ${perms:1:3}
		return
	fi

	if [ "${2}" == "group" ]; then
		echo -e ${perms:4:3}
		return
	fi

	if [ "${2}" == "other" ]; then
		echo -e ${perms:7:3}
		return
	fi
}

function appendFile
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file text"
		return 1
	fi

	if [ ! -f ]; then
		echo -e "File: ${1} does not exist"
		return 2
	fi
	
	echo -e "${2}" >> "${1}" || ( echo -e "Failed to write text to file:${1}" && return 3 )
}

function appendFileBefore
{
	local buffer

	if [ $# != 3 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file-name regexp text"
		return 1
	fi

	checkWrite "${1}" || return 2

	buffer=`cat "${1}" | sed "\#${2}#i\${3}"`
	echo -e "${buffer}" > "${1}"
}

function appendFileAfter
{
	local buffer

	if [ $# != 3 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file-name regexp text"
		return 1
	fi

	checkWrite "${1}" || return 2

	buffer=`cat "${1}" | sed "\#${2}#a\${3}"`
	echo -e "${buffer}" > "${1}"
}

function replaceInFile
{
	local buffer

	if [ $# != 3 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file-name regexp text"
		return 1
	fi

	checkRead "${1}" || return 2
	checkWrite "${1}" || return 3

	buffer=`cat "${1}" | sed -r "s#${2}#${3}#g"`
	echo -e "${buffer}" > "${1}"
}

function removeFromFile 
{
	local buffer

	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file regexp"
		return 1
	fi

	checkWrite "${1}"

	buffer=`cat "${1}" | sed -E "\#${2}#d"`
	echo -e "${buffer}" > "${1}"
}

function toUpper
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} string"
		return 1
	fi

	echo "${1}" | awk '{ print toupper($0) }'
}

function toLower
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} string"
		return 1
	fi

	echo "${1}" | awk '{ print toupper($0) }'
}

function touchFile
{
	if [[ $# < 2 ]]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file-name owner [group=owner] [owner-perm=rw] [group-perm=rw] [other-perm=-]"
		return 1
	fi	

	local owner="${2}"
	local group="${owner}"
	local ownerPerm="rw"
	local groupPerm="rw"
	local otherPerm="-"

	if (( $# >= 3 )); then
		group="${3}"
	fi

	if (( $# >= 4 )); then
		ownerPerm="${4}"
	fi

	if (( $# >= 5 )); then
		groupPerm="${5}"
	fi

	if (( $# == 6 )); then
		otherPerm="${6}"
	fi

	touch "${1}" || return 2
	chown "${owner}:${group}" "${1}" || return 3
	chmod "u=${ownerPerm}" "${1}" || return 4
	chmod "g=${groupPerm}" "${1}" || return 5
	chmod "o=${otherPerm}" "${1}" || return 6
}

function regexpEscape
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} string-to-escape"
		return 1
	fi

	local tmp="${1}"

	tmp=`echo "${tmp}" | sed 's#\.#\\\\.#g'`
	tmp=`echo "${tmp}" | sed 's#{#\\\\{#g'`
	tmp=`echo "${tmp}" | sed 's#}#\\\\}#g'`
	
	echo "${tmp}"
}

function interfaceList
{
	#ifconfig -s | awk 'BEGIN { FS=" " } ; { print $1 }' | awk '{ if(NR!=1) { print} }'
	ip addr | grep -Eo -e "^[0-9]:[\t ][A-Za-z0-9]+" | awk 'BEGIN { FS=" " } ; { print $2 }'
}

function interfaceIP
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} iface-name"
		return 1
	fi

	ifconfig  "${1}" | grep -E -e "[[:blank:]]+(inet)[[:blank:]]+" | awk 'BEGIN { FS=" " } ; { print $2 }'
}

function initArg
{
	_args=( "${@}" )
}

function sizeArg
{
	if [ $# == 0 ]; then 
		if [ ${#_args[@]} == 0 ]; then
			return 1
		else
			return 0
		fi
	fi

	count=0
	for arg in "${_args[@]}"
	do
		if [ "${arg}" == "-${1}" ]; then
			(( count++ ))
		fi
	done
	
	echo "$count"
}

function hasArg
{
	if [ $# != 1 ]; then 
		echo -e "Invalid number of arguments should be:${FUNCNAME} arg-name"
		return 1
	fi

	local sarg="-${1}"

	for arg in "${_args[@]}"
	do
		if [ "${arg}" == "${sarg}" ]; then
			return 0
		fi
	done

	return 2
}

function valueArg
{
	if [[ $# > 2 ]]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} arg-name [index]"
		return 1
	fi

	local sarg="-${1}"
	local i=0
	local j

	if [ $# == 1 ]; then
		j=0
	else
		j=$2
	fi
	
	for arg in "${_args[@]}"
	do
		if [ "${arg}" == "${sarg}" ]; then
			if (( ${#_args[@]} == $((i+1)) )); then
                                return 2    
                        fi  

			if [ $j == 0 ]; then
				((++i))
				echo "${_args[$i]}"
				return 0
			fi

			((--j))
		fi

		((++i))
	done

	return 3
}

function arrayDiff
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} left-array right-array"
		return 1
	fi

	local lhs="${1}"
	local rhs="${2}"
	local -a ret

	for i in "${lhs[@]}"; do
	     local skip=
	     for j in "${rhs[@]}"; do
	         [[ $i == $j ]] && { skip=1; break; }
	     done
	     [[ -n $skip ]] || ret+=("$i")
	done
	
	if (( ${#ret[@]} )); then
		echo "${ret[@]}"
	fi
}

function strindex
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} string substring"
	fi

        local ret="${1%%${2}*}"
        [[ "${ret}" == "${1}" ]] && echo -1 || echo "${#ret}"
}


function strToArray
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be:${FUNCNAME} string separator"
		return 1
	fi

	local buffer="${1}"
	local pos
	local delimLen="${#2}"
	local -a ret

	for ((;${#buffer};)); do
		pos=$( strindex "${buffer}" "${2}" )
		[ $pos == "-1" ] && break
		pos=$(( $pos + $delimLen ))
		ret+=( "${buffer:0:$pos}" )
		buffer="${buffer:$pos}"
	done

	if (( ${#ret[@]} )); then
		echo "${ret[@]}"
	fi
}

function randomInt32
{
	echo $RANDOM > /dev/urandom

	local ret=$( dd status=none if=/dev/urandom count=4 bs=1 | od -t d -A none | grep -Eo -e "*[0-9]+" )
	
	if [ $# == 1 ]; then
		ret=$(( $ret % $1 ))
	fi

	echo "$ret"
}

function fileLines
{
	if [ $# != 1 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file"
		return 1
	fi

	wc -l "${1}" | grep -Eo -e "^[0-9]+"
}

function fileNthLine
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file line-number"
		return 1
	fi

	sed -n "${2}p" < "${1}"
}

function createImage
{
	if [ $# != 2 ]; then
		echo -e "Invalid number of arguments should be: ${FUNCNAME} file size"
		return 1
	fi

	fallocate -l $1 "${2}" &> /dev/null
}
